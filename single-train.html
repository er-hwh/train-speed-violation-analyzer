<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Single Train â€“ Home Signal Violation Analysis</title>

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<!-- PapaParse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<!-- XLSX -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
html, body {
  height: 100%;
  margin: 0;
}
#map {
  height: 100vh;
  width: 100%;
}
#topPanel {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  width: 96%;
  max-width: 1200px;
}
.stat {
  font-weight: 600;
  font-size: 14px;
}
</style>
</head>

<body>

<!-- TOP PANEL -->
<div id="topPanel">
  <div class="card shadow">
    <div class="card-body row g-2 align-items-center">

      <div class="col-md-2">
        <b>ðŸš† Train:</b>
        <span id="trainInfo">NA</span>
      </div>

      <div class="col-md-2">
        <b>ðŸ“… Date:</b>
        <span id="dateInfo">NA</span>
      </div>

      <div class="col-md-3">
        <label class="form-label mb-0">SPM GPS Data</label>
        <input type="file" id="spmFile" class="form-control" accept=".csv,.xlsx,.xls">
      </div>

      <div class="col-md-3">
        <label class="form-label mb-0">FSD (Home Signals)</label>
        <input type="file" id="fsdFile" class="form-control" accept=".csv,.xlsx,.xls">
      </div>

      <div class="col-md-2 d-grid">
        <button class="btn btn-primary" id="analyzeBtn">
          Analyze
        </button>
      </div>

      <div class="col-12 mt-2 d-flex justify-content-between flex-wrap">
        <div class="stat">Points: <span id="statPoints">0</span></div>
        <div class="stat">Stops: <span id="statStops">0</span></div>
        <div class="stat">Homes: <span id="statHomes">0</span></div>
        <div class="stat">Violations: <span id="statViol">0</span></div>
        <div class="stat">Max @ Home: <span id="statMaxHome">0</span> kmph</div>

        <button class="btn btn-sm btn-success" onclick="exportViolations()">
          Export Violations CSV
        </button>
      </div>

    </div>
  </div>
</div>

<!-- MAP -->
<div id="map"></div>

<!-- Leaflet -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ================= CONFIG ================= */
const PASS_LIMIT = 60;
const GOODS_LIMIT = 30;

const STOP_SPEED = 1;
const STOP_MIN_SEC = 20;
const HOME_MATCH_RADIUS = 80; // meters

/* ================= GLOBALS ================= */
let map, layerGroup;
let spmData = [];
let fsdHomes = [];
let stopReport = [];
let violationReport = [];

/* ================= URL PARAMS ================= */
const params = new URLSearchParams(window.location.search);
const trainNo = params.get("train") || "NA";
const dateStr = params.get("date") || "NA";

document.getElementById("trainInfo").innerText = trainNo;
document.getElementById("dateInfo").innerText = dateStr;

/* ================= MAP INIT ================= */
map = L.map("map", {
  center: [22.5, 88.3],
  zoom: 6,
  preferCanvas: true
});

L.tileLayer("https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", {
  maxZoom: 19,
  subdomains: ["mt0","mt1","mt2","mt3"]
}).addTo(map);

layerGroup = L.layerGroup().addTo(map);

/* ================= ICONS ================= */
const homeOKIcon = L.divIcon({
  html: "ðŸŸ¢",
  iconSize: [20, 20],
  className: ""
});

const homeViolIcon = L.divIcon({
  html: "ðŸ”´",
  iconSize: [20, 20],
  className: ""
});

/* ================= PARSER ================= */
function parseFile(file, callback) {
  if (!file) return;

  const ext = file.name.split(".").pop().toLowerCase();

  if (ext === "csv") {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: res => callback(res.data)
    });
    return;
  }

  if (ext === "xlsx" || ext === "xls") {
    const reader = new FileReader();
    reader.onload = e => {
      const wb = XLSX.read(new Uint8Array(e.target.result), { type: "array" });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(sheet, { defval: "" });
      callback(json);
    };
    reader.readAsArrayBuffer(file);
  }
}

/* ================= HELPERS ================= */
function find(row, keys) {
  for (let k in row) {
    const ck = k.toLowerCase().replace(/\s|\./g, "");
    for (let key of keys)
      if (ck.includes(key)) return row[k];
  }
  return null;
}

function detectType(train) {
  if (!train) return "PASS";
  return /^\d+$/.test(train.toString()) ? "PASS" : "GOODS";
}

function distanceMeters(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);

  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) *
    Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) ** 2;

  return Math.round(R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
}

/* ================= LOADERS ================= */
function loadSPM(data) {
  spmData = [];

  data.forEach(r => {
    const lat = parseFloat(find(r, ["latitude", "lat"]));
    const lon = parseFloat(find(r, ["longitude", "lon"]));
    const speed = parseFloat(find(r, ["speed"]));
    const time = find(r, ["logging", "time"]);

    if (isNaN(lat) || isNaN(lon) || isNaN(speed)) return;

    spmData.push({ lat, lon, speed, time });
  });
}

function loadFSD(data) {
  fsdHomes = [];

  data.forEach(r => {
    if (!r.Type || r.Type.toString().toUpperCase() !== "HOME") return;

    const station = r.Station?.toString().trim().toUpperCase();
    if (!station) return;

    let dirn = "";

    if (r.DIRN) {
      const d = r.DIRN.toString().toUpperCase();
      if (d.includes("UP")) dirn = "UP";
      else if (d.includes("DN")) dirn = "DN";
    }

    if (!dirn && r["Station-DIR"]) {
      const sd = r["Station-DIR"].toString().toUpperCase();
      if (sd.endsWith("-UP")) dirn = "UP";
      else if (sd.endsWith("-DN")) dirn = "DN";
    }

    const lat = parseFloat(r.Latitude);
    const lon = parseFloat(r.Longitude);
    if (isNaN(lat) || isNaN(lon)) return;

    fsdHomes.push({ station, dirn, lat, lon });
  });
}

/* ================= ANALYZE ================= */
document.getElementById("analyzeBtn").onclick = () => {
  const spmFile = document.getElementById("spmFile").files[0];
  const fsdFile = document.getElementById("fsdFile").files[0];

  if (!spmFile || !fsdFile) {
    alert("Upload both SPM and FSD files");
    return;
  }

  layerGroup.clearLayers();
  stopReport = [];
  violationReport = [];

  parseFile(spmFile, data => {
    loadSPM(data);
    parseFile(fsdFile, data2 => {
      loadFSD(data2);
      runAnalysis();
    });
  });
};

/* ================= CORE ================= */
function runAnalysis() {
  let bounds = [];
  let homesChecked = 0;
  let homesViol = 0;
  let maxHomeSpeed = 0;

  const type = detectType(trainNo);
  const LIMIT = type === "PASS" ? PASS_LIMIT : GOODS_LIMIT;

  /* ===== ROUTE & STOPS ===== */
  let route = [];
  let stopBuffer = [];
  let currentStop = null;

  spmData.forEach(p => {
    const pos = [p.lat, p.lon];
    route.push(pos);
    bounds.push(pos);

    // STOP DETECT
    if (p.speed <= STOP_SPEED) {
      stopBuffer.push(p);
      if (!currentStop) currentStop = { start: p.time };
    } else {
      finalizeStop(stopBuffer, currentStop);
      stopBuffer = [];
      currentStop = null;
    }

    // DRAW POINT
    L.circleMarker(pos, {
      radius: 3,
      color: "#1E90FF",
      weight: 1,
      fillOpacity: 0.8
    }).addTo(layerGroup);
  });

  finalizeStop(stopBuffer, currentStop);

  if (route.length > 1) {
    L.polyline(route, {
      color: "#555",
      weight: 2,
      opacity: 0.7
    }).addTo(layerGroup);
  }

  /* ===== HOME SIGNAL MATCH ===== */
  fsdHomes.forEach(home => {
    homesChecked++;

    const match = findNearestSPM(home);
    if (!match) return;

    maxHomeSpeed = Math.max(maxHomeSpeed, match.speed);

    const violated = match.speed > LIMIT;
    if (violated) homesViol++;

    if (violated) {
      violationReport.push({
        Station: home.station,
        DIRN: home.dirn,
        Speed: match.speed,
        Limit: LIMIT,
        Time: match.time,
        Distance_m: match.distance
      });
    }

    L.marker([home.lat, home.lon], {
      icon: violated ? homeViolIcon : homeOKIcon
    })
    .bindPopup(`
      <b>HOME SIGNAL</b><br>
      <b>Station:</b> ${home.station}<br>
      <b>DIRN:</b> ${home.dirn}<br>
      <b>Speed:</b> ${match.speed} kmph<br>
      <b>Limit:</b> ${LIMIT}<br>
      <b>Status:</b> ${violated ? "ðŸš¨ VIOLATION" : "OK"}<br>
      <b>Distance:</b> ${match.distance} m<br>
      <b>Time:</b> ${match.time}
    `)
    .addTo(layerGroup);

    bounds.push([home.lat, home.lon]);
  });

  if (bounds.length) {
    map.fitBounds(bounds, { padding: [40, 40] });
  }

  // SUMMARY
  document.getElementById("statPoints").innerText = spmData.length;
  document.getElementById("statStops").innerText = stopReport.length;
  document.getElementById("statHomes").innerText = homesChecked;
  document.getElementById("statViol").innerText = homesViol;
  document.getElementById("statMaxHome").innerText = maxHomeSpeed.toFixed(1);
}

/* ================= MATCH ENGINE ================= */
function findNearestSPM(home) {
  let best = null;
  let minDist = Infinity;

  spmData.forEach(p => {
    const d = distanceMeters(home.lat, home.lon, p.lat, p.lon);
    if (d < minDist) {
      minDist = d;
      best = p;
    }
  });

  if (minDist <= HOME_MATCH_RADIUS) {
    return {
      ...best,
      distance: minDist
    };
  }
  return null;
}

/* ================= STOP FINALIZER ================= */
function finalizeStop(buffer, meta) {
  if (!buffer.length || !meta) return;

  const duration = buffer.length;
  if (duration < STOP_MIN_SEC) return;

  const avgLat = buffer.reduce((s, p) => s + p.lat, 0) / buffer.length;
  const avgLon = buffer.reduce((s, p) => s + p.lon, 0) / buffer.length;

  stopReport.push({
    start: meta.start,
    end: buffer[buffer.length - 1].time,
    duration,
    lat: avgLat.toFixed(6),
    lon: avgLon.toFixed(6)
  });

  L.circleMarker([avgLat, avgLon], {
    radius: 9,
    color: "#000",
    fillColor: "#8B0000",
    fillOpacity: 0.9,
    weight: 2
  })
  .bindPopup(`
    <b>STOP EVENT</b><br>
    <b>Start:</b> ${meta.start}<br>
    <b>End:</b> ${buffer[buffer.length - 1].time}<br>
    <b>Duration:</b> ${duration} sec
  `)
  .addTo(layerGroup);
}

/* ================= EXPORT ================= */
function exportViolations() {
  if (!violationReport.length) {
    alert("No violations found");
    return;
  }

  let csv = "Station,DIRN,Speed,Limit,Time,Distance(m)\n";
  violationReport.forEach(v => {
    csv += `${v.Station},${v.DIRN},${v.Speed},${v.Limit},${v.Time},${v.Distance_m}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `home_violations_${trainNo}_${dateStr}.csv`;
  a.click();

  URL.revokeObjectURL(url);
}
</script>

</body>
</html>
